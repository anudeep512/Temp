Rasa Server:
The rasa server primarily handles the processing of incoming messages and the management of conversations. It uses a transformer model to interpret user inputs, decide on the next action based on the current conversation state, and manage dialogue flows.
This server is responsible for NLU understanding and it also determines the appropriate response or action to take based on the defined dialogue management.

Rasa actions server:
The Rasa action server is designed to handle the execution of custom actions. Custom actions are tasks that you define which require executing code or external logic that cannot be
handled directly using inbuilt dialogue management tools.
This includes operations such as querying a database, calling an external API, or any other complex operation.

When the Rasa server decides that a custom action is the next step in a conversation, it sends a request to the action server with details about the current conversation state. The action server then executes the required action and sends the results back to the Rasa server.

Communication between rasa server and rasa action server:

1) What information is sent from Rasa server to Rasa action server?
- The Rasa server sends a request to the action server that includes details about the current conversation state. This includes the intent that was recognized, the entities extracted.
- The information is sent as an HTTP POST request to the action server.

2) How is that information processed at the Rasa action server?
- The action server receives the HTTP POST request and parses the JSON payload. It then uses this information to determine which action to execute based on the current state of the conversation.
- The info is retrived directly from the incoming HTTP request sent by the Rasa server.

3) What is returned from the action server?
- The action server returns a list of events and/or responses that should be executed next in the conversation. This can include messages to be sent back to the user, updates to the conversation state.
- The response is sent back as an HTTP response to the original request made by the Rasa server

4) How is the return data from Rasa action server processed in Rasa server?
- Once the Rasa server receives the response from the action server, it processes the JSON payload to interpret the list of events and actions returned. Based on these, it updates the conversation state, determines the next actions.
- This information is retrieved from the HTTP response received from the action server

Elaborated explanation of the process:
There are 10 steps included in the Communication between rasa server and rasa actions server.

1) Modifying user input data to be sent to the action server from actions server.
File: rasa/core/actions/action.py
The _action_call_format method in the RemoteAction class helps in formatting the user input data into a structured JSON object that is then sent to the Rasa Action Server.


2) Sending Request from Rasa Server to Rasa Action Server
File: rasa/core/actions/action.py
The action_endpoint.request method sends an HTTP POST request to the action server. The payload is the JSON body prepared earlier.


3) Receiving the Request in Rasa Action Server
File: rasa_sdk/executor.py
The run() method in ActionExecutor class is responsible for processing incoming requests to run actions. The method starts by extracting the name of the action (action_name) that needs 
to be executed from the action_call dictionary. This dictionary is part of the request payload sent from the Rasa server to the action server.


4) Processing Received Request in Rasa Action Server
File: rasa_sdk/executor.py
The method begins by extracting the next_action value from the incoming request dictionary (action_call). This helps in determining the data action to be
performed by the rasa actions server.
The code then attempts to retrieve the corresponding action function from the actions dictionary, which holds all registered actions. 
If the specified action is not found, the ActionNotFoundException is raised.
The call_potential_coroutine utility is used to handle the action with the dispatcher, tracker, and domain as arguments.
After the action executes, it returns a list of events. These events are then validated for conforming expected structures are received or not.


5) Preparing Data for Return from Rasa Action Server
File: rasa_sdk/executor.py
The _create_api_response method is called which is a method in the class ActionExecutor. This method structures the response in a dictionary format that the Rasa Server expects.


6) Sending Response from Rasa Action Server to Rasa Server
File: rasa_sdk/executor.py
The prepared response dictionary is returned from the run() method in the ActionExecutor class. This is the end for action server's processing for the current request.


7) Receiving Response at Rasa Server from Rasa Action Server
File: rasa/core/actions/action.py
The RemoteAction.run() method is used to send a request to the action server and handle the response, this method awaits a response from the action server. The response is then processed to extract events and messages, 
which are returned to update the conversation state in the Rasa server.


8) Processing Received Data at Rasa Server
File: rasa/core/actions/action.py
In the RemoteAction.run() method the values of events and responses are extracted from the validated JSON response.
events typically include changes to the conversation state, like updating slots or triggering specific bot actions.
responses are processed to generate BotUttered events, which are the messages that the bot will send back to the user

9) Executing Events Processed in the Previous Step
File: rasa/core/actions/action.py
The execution of events processed in the previous steps in the Rasa framework is handled in the Action class's run method.
The method is designed to perform the action's side effects, which may involve sending messages to the user, updating the conversation state, or updating the slot values and many other things.
This method is overridden in each subclass of Action to implement the specific effects of that action, such as sending a text message, setting a slot, calling an external API, or any custom behavior defined in custom actions
The actual code where these events are performed vary depending upon the event which we are interested in.  


10) Response Generation and Output to Channel
File: rasa/core/channels/channel.py
This send_response method in OuputChannel class determines what type of content is included in the message (e.g., text, buttons, images) and calls the appropriate function to send that content type.
The response is then sent to suitable channel.

11) Handling REST API request 
File: rasa/core/channels/rest.py
This file includes the implementation for the REST channel, which processes incoming HTTP requests and sends responses back via the same HTTP connection.
The attached code block defines how the server processes incoming POST requests to the /webhook endpoint and responds to them.
Extracting Request Data:
The methods _extract_sender, _extract_message, _extract_input_channel, get_metadata are used to understand the input message
Message Processing:
The UserMessage object is created with the extracted data and passed to the on_new_message function. This is then passed to the rasa server.
Collecting and Returning Response:
Once all messages are collected in the CollectingOutputChannel, they are returned together as a JSON response. This includes all bot responses generated from the user's input.
if we streaming is enabled then response is sent back in chunks as they are generated.

